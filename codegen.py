"""
Phase 6: Code Generator
Generates Python code from optimized quadruples.
"""

from typing import List
from icg import Quadruple
from semantic import SymbolInfo


class CodeGenerator:
    """Generates Python code from quadruples."""
    
    def __init__(self, quads: List[Quadruple], symbol_table: dict, circuit_name: str):
        self.quads = quads
        self.symbol_table = symbol_table
        self.circuit_name = circuit_name
    
    def get_inputs(self) -> List[str]:
        """Get all INPUT identifiers."""
        return [
            name for name, info in self.symbol_table.items()
            if info.category == 'INPUT'
        ]
    
    def get_outputs(self) -> List[str]:
        """Get all OUTPUT identifiers."""
        return [
            name for name, info in self.symbol_table.items()
            if info.category == 'OUTPUT'
        ]
    
    def generate_operation(self, quad: Quadruple) -> str:
        """Convert a quadruple to Python code."""
        if quad.op == 'ASSIGN':
            return f"    {quad.result} = {quad.arg1}\n"
        
        elif quad.op == 'NOT':
            return f"    {quad.result} = int(not {quad.arg1})\n"
        
        elif quad.op == 'AND':
            return f"    {quad.result} = {quad.arg1} & {quad.arg2}\n"
        
        elif quad.op == 'OR':
            return f"    {quad.result} = {quad.arg1} | {quad.arg2}\n"
        
        elif quad.op == 'XOR':
            return f"    {quad.result} = {quad.arg1} ^ {quad.arg2}\n"
        
        elif quad.op == 'NAND':
            return f"    {quad.result} = int(not ({quad.arg1} & {quad.arg2}))\n"
        
        elif quad.op == 'NOR':
            return f"    {quad.result} = int(not ({quad.arg1} | {quad.arg2}))\n"
        
        return ""
    
    def generate_truth_table(self, inputs: List[str], outputs: List[str]) -> str:
        """Generate code to print truth table."""
        code = "# Truth Table\n"
        code += f'print("{ "  ".join(inputs)} || { "  ".join(outputs)}")\n'
        code += 'print("-" * 40)\n\n'
        
        num_inputs = len(inputs)
        for i in range(2 ** num_inputs):
            # Generate binary values
            values = format(i, f'0{num_inputs}b')
            args = ', '.join(values)
            
            code += f'result = simulate({args})\n'
            
            # Handle single vs multiple outputs
            if len(outputs) == 1:
                code += f'print(f"{ "  ".join(values)} || {{result}}")\n'
            else:
                output_str = '  '.join([f'{{result[{i}]}}' for i in range(len(outputs))])
                values_str = '  '.join(values)
                code += f'print(f"{values_str} || {output_str}".format(result=result))\n'
        
        return code
    
    def generate(self) -> str:
        """Generate complete Python code."""
        inputs = self.get_inputs()
        outputs = self.get_outputs()
        
        code = f"# Generated by Logic Gate Architect Compiler\n"
        code += f"# Circuit: {self.circuit_name}\n\n"
        
        # Function definition
        code += f"def simulate({', '.join(inputs)}):\n"
        
        # Gate operations
        for quad in self.quads:
            code += self.generate_operation(quad)
        
        # Return statement
        if len(outputs) == 1:
            code += f"    return {outputs[0]}\n\n"
        else:
            code += f"    return {', '.join(outputs)}\n\n"
        
        # Truth table
        code += self.generate_truth_table(inputs, outputs)
        
        return code


if __name__ == "__main__":
    from lexer import Lexer
    from parser import Parser
    from semantic import SemanticAnalyzer
    from icg import IntermediateCodeGenerator
    from optimizer import Optimizer
    
    test_code = """
    CIRCUIT HalfAdder {
        INPUT A, B;
        OUTPUT Sum, Carry;
        Sum = XOR(A, B);
        Carry = AND(A, B);
    }
    """
    
    lexer = Lexer()
    tokens = lexer.tokenize(test_code)
    
    parser = Parser(tokens)
    ast = parser.parse()
    
    analyzer = SemanticAnalyzer(ast)
    result = analyzer.analyze()
    
    icg = IntermediateCodeGenerator(ast)
    quads = icg.generate()
    
    optimizer = Optimizer(quads, result['symbol_table'])
    optimized = optimizer.optimize()
    
    codegen = CodeGenerator(optimized, result['symbol_table'], ast.name)
    python_code = codegen.generate()
    
    print(python_code)

